# -*- coding: utf-8 -*-
"""Augmentation_CSV.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S0GbvPg-Hwb_kBDxHaXOVRjnvPonry5Y
"""

#if necessary

from google.colab import drive
drive.mount('/content/gdrive')

#import libraries
import os
import ast
from collections import namedtuple

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

from tqdm import tqdm
from PIL import Image

import joblib
from joblib import Parallel, delayed


import cv2
import albumentations
from albumentations.pytorch.transforms import ToTensorV2
from albumentations.core.transforms_interface import DualTransform
#from albumentations.augmentations.bbox_utils import denormalize_bbox, normalize_bbox

from sklearn.model_selection import StratifiedKFold

import glob
from numpy import asarray
import albumentations as A

import torch
from torch.utils.data import DataLoader, Dataset
import torch.utils.data as data_utils

from matplotlib import pyplot as plt
import matplotlib.patches as patches
from matplotlib.image import imsave

"""functions:

"""

def draw_rect_with_labels(img, bboxes,class_id, class_dict, color=None):
    img = img.copy()
    bboxes = bboxes[:, :4]
    bboxes = bboxes.reshape(-1, 4)
    for bbox, label in zip(bboxes, class_id):
        pt1, pt2 = (bbox[0], bbox[1]), (bbox[2], bbox[3])
        pt1 = int(pt1[0]), int(pt1[1])
        pt2 = int(pt2[0]), int(pt2[1])
        class_name = class_dict[label[4]]
        ((text_width, text_height), _) = cv2.getTextSize(class_name, cv2.FONT_HERSHEY_SIMPLEX, 0.35, 1)
        img = cv2.rectangle(img.copy(), pt1, pt2, color, int(max(img.shape[:2]) / 200))
        img = cv2.putText(img.copy(), class_name, (int(bbox[0]), int(bbox[1]) - int(0.3 * text_height)), cv2.FONT_HERSHEY_SIMPLEX,fontScale=1,color = (255,255,255), lineType=cv2.LINE_AA)
    return img




## using my good old plotting functions
def plot_multiple_img(img_matrix_list, title_list, ncols, main_title=""):
    fig, myaxes = plt.subplots(figsize=(20, 15), nrows=1, ncols=ncols, squeeze=False)
    fig.suptitle(main_title, fontsize = 30)
    fig.subplots_adjust(wspace=0.3)
    fig.subplots_adjust(hspace=0.3)
    for i, (img, title) in enumerate(zip(img_matrix_list, title_list)):
        myaxes[i // ncols][i % ncols].imshow(img)
        myaxes[i // ncols][i % ncols].set_title(title, fontsize=15)
    plt.show()

def build_df_for_image(name_img):
  image_folder_path = "../train"
  chosen_image = cv2.imread(os.path.join(image_folder_path, name_img))

  plt.imshow(chosen_image)
  chosen_image_dataframe = train_df.loc[train_df["image"]==name_img,["xmin","ymin","xmax","ymax","label"]]
  bbox_array_of_chosen_image = np.array(chosen_image_dataframe.values.tolist())

  labels_of_chosen_image = (len(bbox_array_of_chosen_image))
  print(name_img)
  print("build_df_for_image")
  print(bbox_array_of_chosen_image.shape)
  return chosen_image, bbox_array_of_chosen_image, bbox_array_of_chosen_image

def draw_rect(image, bbox):
    # Draw a rectangle based on the data from the bbox
    for i in bbox:
        image_with_rect = cv2.rectangle(image, (int(i[0]), int(i[1])), (int(i[2]), int(i[3])), (0, 255, 0), 2)
        plt.imshow(image_with_rect)
    return image_with_rect

def draw_labels(image,bbox_array_of_chosen_image):
   print("draw_labels")
   draw_chosen_image = draw_rect(image.copy(), bbox_array_of_chosen_image.copy())
   plt.imshow(draw_chosen_image)

def GFlip(name_img,chosen_image,bbox_array_of_chosen_image,labels_of_chosen_image):# Augmentation: Changing the image to grayscale
  ver_flip = A.Compose([
        A.ToGray(p=1),
    ], bbox_params={'format': 'pascal_voc', 'label_fields': ['labels']})

  ver_flip_annotations = ver_flip(image=chosen_image, bboxes=bbox_array_of_chosen_image,labels=labels_of_chosen_image)
  ver_flip_annotations['bboxes'] = [list(bbox) for bbox in ver_flip_annotations['bboxes']]
  ver_flip_img = draw_rect_with_labels(img = ver_flip_annotations['image'], bboxes = np.array(ver_flip_annotations['bboxes']),
                          class_id = ver_flip_annotations['labels'], class_dict = {0: "a",1: "a"}, color=(255,0,0))


  #Saving the new image
  plt.imsave("../train_aug/"+"G"+name_img, ver_flip_annotations['image'])


#Saving the new label according to the augmentation to a csv file
  for i in ver_flip_annotations['bboxes']:
    check_df.loc[len(check_df),:]= ["G"+name_img, i[0], i[1] ,i[2] ,i[3] ,i[4] ]

    #print(new_row)
  #ptint the size of the csv file
  print(check_df.shape)

  plt.imshow(ver_flip_img)

def HFlip(name_img,chosen_image,bbox_array_of_chosen_image,labels_of_chosen_image): #Augmentation: horizontal rotation
  ver_flip = A.Compose([
        A.HorizontalFlip(p=1),
    ], bbox_params={'format': 'pascal_voc', 'label_fields': ['labels']})

  ver_flip_annotations = ver_flip(image=chosen_image, bboxes=bbox_array_of_chosen_image,labels=labels_of_chosen_image)
  ver_flip_annotations['bboxes'] = [list(bbox) for bbox in ver_flip_annotations['bboxes']]
  ver_flip_img = draw_rect_with_labels(img = ver_flip_annotations['image'], bboxes = np.array(ver_flip_annotations['bboxes']),
                          class_id = ver_flip_annotations['labels'], class_dict = {0: "a",1: "a"}, color=(255,0,0))

  #Saving the new image
  plt.imsave("../train_aug/"+"H"+name_img, ver_flip_annotations['image'])

  #Saving the new label according to the augmentation to a csv file
  for i in ver_flip_annotations['bboxes']:
    check_df.loc[len(check_df),:]= ["H"+name_img, i[0], i[1] ,i[2] ,i[3] ,i[4] ]

    #print(new_row)
  #ptint the size of the csv file
  print(check_df.shape)
  plt.imshow(ver_flip_img)

def VFlip(name_img,chosen_image,bbox_array_of_chosen_image,labels_of_chosen_image): #Augmentation: vertical rotation
  ver_flip = A.Compose([
         A.VerticalFlip(p=1),
    ], bbox_params={'format': 'pascal_voc', 'label_fields': ['labels']})

  ver_flip_annotations = ver_flip(image=chosen_image, bboxes=bbox_array_of_chosen_image,labels=labels_of_chosen_image)
  ver_flip_annotations['bboxes'] = [list(bbox) for bbox in ver_flip_annotations['bboxes']]
  ver_flip_img = draw_rect_with_labels(img = ver_flip_annotations['image'], bboxes = np.array(ver_flip_annotations['bboxes']),
                          class_id = ver_flip_annotations['labels'], class_dict = {1: "a"}, color=(255,0,0))

  #Saving the new image
  plt.imsave("../train_aug/"+"V"+name_img, ver_flip_annotations['image'])

  #Saving the new label according to the augmentation to a csv file
  for i in ver_flip_annotations['bboxes']:
    check_df.loc[len(check_df),:]= ["V"+name_img, i[0], i[1] ,i[2] ,i[3] ,i[4] ]

    #print(new_row)
  #ptint the size of the csv file
  print(check_df.shape)
  plt.imshow(ver_flip_img)

"""Main:"""

#Preprocessing of the label csv file

train_df=pd.read_csv("../all_data.csv")
train_df['label'] = train_df['label'].replace("c",1)
train_df['image'] = train_df['image'].str[:-4] #
train_df.to_csv("../all_data.csv")
train_df

# Build an empty csv file for the new labels
check_df=train_df
#check_df.drop(['Unnamed: 0'], axis=1, inplace=True)
check_df = check_df.drop(check_df[check_df['label'] == 1].index)
check_df

#Going over each file in the folder and making augmentations

for ImP in glob.glob("../all_data/train/*.png"):
  pic = Image.open(ImP)
  name=str(ImP)
  #choose the pic_name according to the length of our file name
  ##control-
  if "Control" in name:
    pic_name=name[-23:]
  ##acidic
  if "Acidic" in name:
    pic_name=name[-22:]

  #print(pic_name)

  #Preprocessing of the image
  numpydata = asarray(pic)
  pic1 = Image.fromarray(numpydata)
  first_img, bbox_img , lable_img =build_df_for_image(pic_name)
  draw_labels(first_img,bbox_img)

  GFlip(pic_name,first_img,bbox_img,lable_img)
  HFlip(pic_name,first_img,bbox_img,lable_img)
  VFlip(pic_name,first_img,bbox_img,lable_img)

"""Save the CSV file of the label of all new augmentations"""

check_df

check_df.to_csv("../AugAll/all_lable.csv")

check_df.to_json("../AugAll/all_lable.json")

check_df.to_xml("../AugAll/all_lable.xml")